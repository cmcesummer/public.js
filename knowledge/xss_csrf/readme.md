# xss csrf

## xss
`Cross Site Scripting`   跨站脚本攻击   
- XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

| 字符 |  	转义后的字符 |
|------|-----------|
| `&` |  `&amp;` |
| `<` |  `&lt;` |
| `>` |  `&gt;` |
| `"` |  `&quot;` |
| `'` |  `&#x27;` |
| `/` |  `&#x2F;` |

- 做了 HTML 转义，并不等于高枕无忧。
- 对于链接跳转，如 `<a href="xxx"` 或 `location.href="xxx"`，要检验其内容，禁止以 `javascript:` 开头的链接，和其他非法的 `scheme`。   

在处理输入时，以下内容都不可信：  

- 来自用户的 UGC 信息
- 来自第三方的链接
- URL 参数
- POST 参数
- Referer （可能来自不可信的来源）
- Cookie （可能来自其他子域注入）

防范
- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- 验证码：防止脚本冒充用户提交危险操作。
- 利用模板引擎 开启模板引擎自带的 HTML 转义功能
- 避免内联事件。尽量不要使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。
- 避免拼接 HTML ，采用比较成熟的渲染框架，如 Vue/React 等。


## csrf
`Cross-site request forgery`  

- 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

我们可以专门制定防护策略，如下：

- 阻止不明外域的访问
    - 同源检测 ：
        1. Origin Header，  
        2. Referer Header 
    - Samesite Cookie
        1. `Set-Cookie: foo=1; Samesite=Strict` 严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外
        2. `Set-Cookie: foo=1; Samesite=Lax`  宽松模式 假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。
        3. Samesite的兼容性不是很好
- 提交时要求附加本域才能获取的信息
    - CSRF Token :
        1. 将CSRF Token输出到页面中
        2. 页面提交的请求携带这个Token
        3. 服务器验证Token是否正确
        4. 但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。
    - 双重Cookie验证
        1. 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如`csrfcookie=v8g9e4ksfhw`）。
        2. 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST `https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）。
        3. 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。
        4. 优点： 无需使用Session，适用面更广，易于实施。Token储存于客户端中，不会给服务器带来压力。相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。
        5. 缺点： 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。难以做到子域名的隔离。
